{"data":{"allSpeakersYaml":{"edges":[{"node":{"uuid":"kinuko-yasuda","name":"Kinuko Yasuda"}},{"node":{"uuid":"hidetaka-okamoto","name":"Hidetaka Okamoto"}},{"node":{"uuid":"thomas-steiner","name":"Thomas Steiner"}},{"node":{"uuid":"okuto-oyama","name":"Okuto Oyama"}},{"node":{"uuid":"junya-kani","name":"可児 潤也"}},{"node":{"uuid":"takuo-kihira","name":"紀平 拓男 (Takuo Kihira)"}},{"node":{"uuid":"berlysia","name":"berlysia"}},{"node":{"uuid":"yoshiya-hinosawa","name":"日野澤歓也"}},{"node":{"uuid":"daishi-kato","name":"Daishi Kato"}},{"node":{"uuid":"yuta-ide","name":"Yuta Ide"}},{"node":{"uuid":"antoine-bourlon","name":"Antoine Bourlon"}},{"node":{"uuid":"qsona","name":"森 久太郎 / qsona"}},{"node":{"uuid":"sosuke-suzuki","name":"Sosuke Suzuki"}},{"node":{"uuid":"tomohiro-kato","name":"加藤 倫弘 / Tomohiro Kato"}},{"node":{"uuid":"kohei-ueno","name":"Kohei Ueno"}},{"node":{"uuid":"asiya","name":"Asiya"}},{"node":{"uuid":"kazuyuki-takase-","name":"Kazuyuki TAKASE (@Guvalif)"}},{"node":{"uuid":"tetsuya-shibutani","name":"Tetsuya Shibutani"}},{"node":{"uuid":"yuku-kotani","name":"Yuku Kotani"}},{"node":{"uuid":"shinyaigeek","name":"しにゃい/Shinyaigeek"}},{"node":{"uuid":"hiroyuki-yagihashi","name":"Hiroyuki Yagihashi"}},{"node":{"uuid":"julien-hora","name":"Julien Hora"}},{"node":{"uuid":"sacha-greif","name":"Sacha Greif"}}]},"allTalksYaml":{"edges":[{"node":{"uuid":"how-to-build-a-media-site-from-the-infrastructure-up-using-only-java-script-type-script","title":"JavaScript(TypeScript)だけでメディアサイトをインフラから構築する方法","titleJa":"JavaScript(TypeScript)だけでメディアサイトをインフラから構築する方法","description":"(Untranslated) 近年、APIベースでwebサーバーなどのインフラ部分を構築できるサービスが増加してきました。中でも一部のサードパーティやベンダーでは、インフラ構成の定義についてもJavaScriptなどのスクリプト言語を利用できるツールやライブラリの公開がはじまっています。\n本セッションでは、AWS CDKやServerless Frameworkを例に、JavaScriptまたはTypeScriptでwebサーバーやAPIバックエンドの構成定義とデプロイを行う方法を紹介します。\nまた、Next.jsを利用したサイト構築の事例を元に、実際に運用する上で注意すべき点やハマりどころ、技術選定のポイントなどについても紹介します。\n# Topic\n- スクリプト言語で行うIaC\n- Serverless Framework / AWS CDKでのインフラ定義のポイント\n- serverless-nextjsの紹介\n- Next.jsをAWS CDKでAWSに公開する際のハマりどころや注意点","descriptionJa":"近年、APIベースでwebサーバーなどのインフラ部分を構築できるサービスが増加してきました。中でも一部のサードパーティやベンダーでは、インフラ構成の定義についてもJavaScriptなどのスクリプト言語を利用できるツールやライブラリの公開がはじまっています。\n本セッションでは、AWS CDKやServerless Frameworkを例に、JavaScriptまたはTypeScriptでwebサーバーやAPIバックエンドの構成定義とデプロイを行う方法を紹介します。\nまた、Next.jsを利用したサイト構築の事例を元に、実際に運用する上で注意すべき点やハマりどころ、技術選定のポイントなどについても紹介します。\n# Topic\n- スクリプト言語で行うIaC\n- Serverless Framework / AWS CDKでのインフラ定義のポイント\n- serverless-nextjsの紹介\n- Next.jsをAWS CDKでAWSに公開する際のハマりどころや注意点","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["hidetaka-okamoto"],"startsAt":"14:00","endsAt":"14:30","room":"B","date":"day1"}},{"node":{"uuid":"the-2021-edition-of-dealing-with-files-on-the-web","title":"The 2021 edition of dealing with files on the Web","titleJa":"The 2021 edition of dealing with files on the Web","description":"The file input element and the download attribute on anchor elements used to be the primary way for working with files on the Web. Not anymore! In this presentation, I will show modern ways of dealing with files in the browser and how they integrate with the clipboard, drag and drop, and your operating system's file explorer. You will also learn that not all files are created equal! This will be a pre-recorded \"live\"-coding session, so expect no slides, no coding glitches; just pure edutainment!","descriptionJa":"（未翻訳）The file input element and the download attribute on anchor elements used to be the primary way for working with files on the Web. Not anymore! In this presentation, I will show modern ways of dealing with files in the browser and how they integrate with the clipboard, drag and drop, and your operating system's file explorer. You will also learn that not all files are created equal! This will be a pre-recorded \"live\"-coding session, so expect no slides, no coding glitches; just pure edutainment!","spokenLanguage":"en","slideLanguage":"en","speakerIDs":["thomas-steiner"],"startsAt":"13:20","endsAt":"13:50","room":"A","date":"day1"}},{"node":{"uuid":"the-past-and-future-of-accessible-front-end-development","title":"アクセシブルなフロントエンド開発のこれまでとこれから","titleJa":"アクセシブルなフロントエンド開発のこれまでとこれから","description":"(Untranslated) 昨今アクセシビリティに関する興味関心が増えてきた中で、SPAといったWebアプリケーションにおけるアクセシビリティを考慮した実装についてはまだ認識が広まっていないように感じます。\nフロントエンドフレームワークを使ってより良いアクセシビリティ実装をするにはどうすればいいかの方法、その結果どういう形で伝わっているかを紹介しようと思います。\nまたWebアプリケーションでHTMLを使ってUI実装することに限界を感じており、それを解消するためのReactGUIやHeadless UIといった新たなアプローチにおける期待についても紹介したいと思っております。","descriptionJa":"昨今アクセシビリティに関する興味関心が増えてきた中で、SPAといったWebアプリケーションにおけるアクセシビリティを考慮した実装についてはまだ認識が広まっていないように感じます。\nフロントエンドフレームワークを使ってより良いアクセシビリティ実装をするにはどうすればいいかの方法、その結果どういう形で伝わっているかを紹介しようと思います。\nまたWebアプリケーションでHTMLを使ってUI実装することに限界を感じており、それを解消するためのReactGUIやHeadless UIといった新たなアプローチにおける期待についても紹介したいと思っております。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["okuto-oyama"],"startsAt":"14:30","endsAt":"15:00","room":"B","date":"day1"}},{"node":{"uuid":"how-to-implement-a-system-that-goes-beyond-amp-caching-on-your-domain","title":"AMP キャッシュを超えるシステムを自社ドメインで実現する方法","titleJa":"AMP キャッシュを超えるシステムを自社ドメインで実現する方法","description":"(Untranslated) ・AMP は、Web Components を用いるためのライブラリとしての側面と Google 独自のキャッシュ配信基盤としての側面を持っている。\n・AMP の提供している Web Components は高速で UX も問題ない。\n・AMP キャッシュは検索結果の時点で HTML をプリフェッチできる利点がある。\n・しかし AMP キャッシュはドメインが Google になるという欠点がある。\n・各種アナリティクスツールの計測観点ではドメインが変わることで必要なマーケティングが行えない。\n・そこで、AMP をライブラリとしてのみ活用し、AMP キャッシュに替わるキャッシュシステムを自分たちで実装して実現した。\n・fastly の CDN を配置し AMP キャッシュと同様の SWR キャッシュを採用した。\n・そして Google Bot が AMP ページをあらかじめキャッシュするように、キャッシュを温めるための自サイト向けクローラを用意した。\n・AMP はライブラリとして使いつつ AMP valid にはさせないよう Next.js や AMP のバリデータに独自の使い方を適用させた。\n・開発体験を充実させるために Next.js x TypeScript x AMP の組み合わせを実現した。\n・さらに SXG キャッシュで検索結果からのプリフェッチも実現した。","descriptionJa":"・AMP は、Web Components を用いるためのライブラリとしての側面と Google 独自のキャッシュ配信基盤としての側面を持っている。\n・AMP の提供している Web Components は高速で UX も問題ない。\n・AMP キャッシュは検索結果の時点で HTML をプリフェッチできる利点がある。\n・しかし AMP キャッシュはドメインが Google になるという欠点がある。\n・各種アナリティクスツールの計測観点ではドメインが変わることで必要なマーケティングが行えない。\n・そこで、AMP をライブラリとしてのみ活用し、AMP キャッシュに替わるキャッシュシステムを自分たちで実装して実現した。\n・fastly の CDN を配置し AMP キャッシュと同様の SWR キャッシュを採用した。\n・そして Google Bot が AMP ページをあらかじめキャッシュするように、キャッシュを温めるための自サイト向けクローラを用意した。\n・AMP はライブラリとして使いつつ AMP valid にはさせないよう Next.js や AMP のバリデータに独自の使い方を適用させた。\n・開発体験を充実させるために Next.js x TypeScript x AMP の組み合わせを実現した。\n・さらに SXG キャッシュで検索結果からのプリフェッチも実現した。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["junya-kani"],"startsAt":"16:20","endsAt":"16:50","room":"A","date":"day1"}},{"node":{"uuid":"implementation-and-business-of-block-pong-a-web-based-casual-game","title":"Web ベースのカジュアルゲーム「Block Pong」の実装とビジネス","titleJa":"Web ベースのカジュアルゲーム「Block Pong」の実装とビジネス","description":"(Untranslated) Block Pong という Web 技術をメインに使っているカジュアルゲームの技術詳細 (浮動小数点演算の誤差の吸収のための wasm と、Canvas の globalCompositeOperation の話を予定しております) の紹介を中心に、Web 技術を使うことによって可能になったビジネスモデルの紹介も少しして、今後の Web におけるゲーム開発の課題や方向性を示します。","descriptionJa":"Block Pong という Web 技術をメインに使っているカジュアルゲームの技術詳細 (浮動小数点演算の誤差の吸収のための wasm と、Canvas の globalCompositeOperation の話を予定しております) の紹介を中心に、Web 技術を使うことによって可能になったビジネスモデルの紹介も少しして、今後の Web におけるゲーム開発の課題や方向性を示します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["takuo-kihira"],"startsAt":"14:00","endsAt":"14:30","room":"A","date":"day1"}},{"node":{"uuid":"testing-approach-to-support-web-front-end-replacement","title":"Webフロントエンドのリプレースを支えるテストの考え方","titleJa":"Webフロントエンドのリプレースを支えるテストの考え方","description":"(Untranslated) Webフロントエンド実装のリプレースや根本的なリファクタリングは、各所で需要が高まっていることと思います。\n画面単位やコンポーネント単位で頑張るといった方針は多く事例が挙がっていますが、その過程をどのようにテストするかについては、個別の事情がより大きく影響することでしょう。\n株式会社ドワンゴが提供するオンライン学習サービスN予備校にて自ら活用したアプローチを中心にして、リプレースやそれに相当するリファクタリングにおけるテストの考え方・パターンを紹介します。","descriptionJa":"Webフロントエンド実装のリプレースや根本的なリファクタリングは、各所で需要が高まっていることと思います。\n画面単位やコンポーネント単位で頑張るといった方針は多く事例が挙がっていますが、その過程をどのようにテストするかについては、個別の事情がより大きく影響することでしょう。\n株式会社ドワンゴが提供するオンライン学習サービスN予備校にて自ら活用したアプローチを中心にして、リプレースやそれに相当するリファクタリングにおけるテストの考え方・パターンを紹介します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["berlysia"],"startsAt":"12:50","endsAt":"13:20","room":"B","date":"day1"}},{"node":{"uuid":"the-past-and-future-of-deno","title":"Deno の これまで と これから","titleJa":"Deno の これまで と これから","description":"(Untranslated) 2018年5月に最初の Deno のプロトタイプが発表されました。2020年5月には Deno 1.0 がリリースされ、その後も様々な機能の開発が進められています。当セッションでは、これまでの Deno の3年間の歩みを振り返りつつ、2022年Q2 に予定されている Deno 2.0 に向けてのロードマップの話をします。","descriptionJa":"2018年5月に最初の Deno のプロトタイプが発表されました。2020年5月には Deno 1.0 がリリースされ、その後も様々な機能の開発が進められています。当セッションでは、これまでの Deno の3年間の歩みを振り返りつつ、2022年Q2 に予定されている Deno 2.0 に向けてのロードマップの話をします。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["yoshiya-hinosawa"],"startsAt":"14:30","endsAt":"15:00","room":"A","date":"day1"}},{"node":{"uuid":"about-the-state-management-library","title":"状態管理ライブラリについて","titleJa":"状態管理ライブラリについて","description":"(Untranslated) パート1: 導入\n状態管理ライブラリとは？ReactステートやContextとの違いは？など基本的なことについて\nパート2: 状態管理ライブラリ三部作について\nJotai、Valitio、Zustandの特徴や違いなどについて\nパート3: React 18と状態管理\nコンカレントレンダリングと状態管理、ティアリングやブランチングなどについて\n","descriptionJa":"パート1: 導入\n状態管理ライブラリとは？ReactステートやContextとの違いは？など基本的なことについて\nパート2: 状態管理ライブラリ三部作について\nJotai、Valitio、Zustandの特徴や違いなどについて\nパート3: React 18と状態管理\nコンカレントレンダリングと状態管理、ティアリングやブランチングなどについて\n","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["daishi-kato"],"startsAt":"15:10","endsAt":"15:40","room":"A","date":"day1"}},{"node":{"uuid":"static-site-generator-is-a-compiler","title":"Static Site Generator is a Compiler","titleJa":"Static Site Generator is a Compiler","description":"(Untranslated) 静的サイトジェネレーターはコンテンツを受け取り、静的サイトを出力します。さらに近頃はただ静的サイトを出力するだけではなく、パフォーマンスの最適化や職人芸を適用した上でサイトを出力するツールも登場しています。\nでは、どのようなサイトに対しても静的サイトジェネレーターを適用することが相応しいのでしょうか。私はそう言い切れるとは思いません。なぜなら最適化が施されたコードを埋めたサイトより、何も埋め込んでいないサイトの方が \"軽い\" からです。しかし要件やデザインを満たすべく様々なコードを埋め込んでいくと、静的サイトジェネレータを使った方が \"速い\" と言い切れる分岐点に出会います。\nそこでこのトークでは一般的な静的サイトジェネレータが行っている最適化手法と、様々な状況下においての手書き HTML とのパフォーマンス比較結果を紹介し、どのような状況下であれば静的サイトジェネレータを使うことによる恩恵が高まるかを報告します。\nそして最後に静的サイトジェネレータの最適化手段を知ることで、既存のツールに囚われることなく product を better product に変換するツールは内製できるという事例を紹介します。","descriptionJa":"静的サイトジェネレーターはコンテンツを受け取り、静的サイトを出力します。さらに近頃はただ静的サイトを出力するだけではなく、パフォーマンスの最適化や職人芸を適用した上でサイトを出力するツールも登場しています。\nでは、どのようなサイトに対しても静的サイトジェネレーターを適用することが相応しいのでしょうか。私はそう言い切れるとは思いません。なぜなら最適化が施されたコードを埋めたサイトより、何も埋め込んでいないサイトの方が \"軽い\" からです。しかし要件やデザインを満たすべく様々なコードを埋め込んでいくと、静的サイトジェネレータを使った方が \"速い\" と言い切れる分岐点に出会います。\nそこでこのトークでは一般的な静的サイトジェネレータが行っている最適化手法と、様々な状況下においての手書き HTML とのパフォーマンス比較結果を紹介し、どのような状況下であれば静的サイトジェネレータを使うことによる恩恵が高まるかを報告します。\nそして最後に静的サイトジェネレータの最適化手段を知ることで、既存のツールに囚われることなく product を better product に変換するツールは内製できるという事例を紹介します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["yuta-ide"],"startsAt":"15:10","endsAt":"15:40","room":"B","date":"day1"}},{"node":{"uuid":"summary-of-the-latest-information-on-tracking-restrictions-and-alternative-api-by-cookies-etc","title":"Cookie等によるトラッキング規制と代替APIの最新情報まとめ","titleJa":"Cookie等によるトラッキング規制と代替APIの最新情報まとめ","description":"(Untranslated) インターネット広告技術（アドテック）業界では、これまで主にcookieを使って、データを自由に取得しサービスを提供していました。一方で、ユーザーのプライバシーに不利益を与えるリスクが課題になっています。\nこの課題に対して、法律（GDPRや個人情報保護法）、OS・ブラウザ（WebKitのITP、ChromeのPrivacy Sandbox）の観点から様々な規制強化と、各種用途（ターゲティング、計測、ボット判定、デバイス判定、ログイン）に限定した代替技術の開発が進められています。\n本Talkではそのような過去～現在における動向と、OS・ブラウザにおける規制、開発中の代替技術(API)の仕組みと議論について解説します。","descriptionJa":"インターネット広告技術（アドテック）業界では、これまで主にcookieを使って、データを自由に取得しサービスを提供していました。一方で、ユーザーのプライバシーに不利益を与えるリスクが課題になっています。\nこの課題に対して、法律（GDPRや個人情報保護法）、OS・ブラウザ（WebKitのITP、ChromeのPrivacy Sandbox）の観点から様々な規制強化と、各種用途（ターゲティング、計測、ボット判定、デバイス判定、ログイン）に限定した代替技術の開発が進められています。\n本Talkではそのような過去～現在における動向と、OS・ブラウザにおける規制、開発中の代替技術(API)の仕組みと議論について解説します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["antoine-bourlon"],"startsAt":"15:40","endsAt":"16:10","room":"A","date":"day1"}},{"node":{"uuid":"technology-selection-for-the-next-n-years-based-on-graphql-and-prisma","title":"GraphQL と Prisma から考える次のN年を見据えた技術選定","titleJa":"GraphQL と Prisma から考える次のN年を見据えた技術選定","description":"(Untranslated) これは、 yasaichi さんによる素晴らしいトーク [Active Recordから考える次の10年を見据えた技術選定](https://speakerdeck.com/yasaichi/architecture-decision-for-the-next-10-years-at-pixta) へのアンサートークです。\n私たちのチームでは新規サービスの開発を行っており、開発初期段階でいくつか技術的な判断を行いました。まず、API (public / internal) のプロトコルを GraphQL に統一しました。そして、内部の主要なサービスのうち一つに Ruby on Rails (ActiveRecord), もう一つに Node.js + Prisma という技術選定を行いました。\n社内で広く使われていた Rails という選択肢を取ったことは自然でしたが、もう一つのサービスに Node.js を選択したこと、また、ORM ライブラリとして ActiveRecord に思想が近い TypeORM ではなく、Prisma を選択したという決断の理由について、主にアーキテクチャ的背景から理由を説明します。\nまた、開発期間が2年弱経ち、見えてきた課題も取り上げます。特に、yasaichi さんの資料でも取り上げられている「トランザクションスクリプトを多く用いることになる」という課題について(実際に起きています)、それがどの程度深刻なのかの分析や、今後対処していく道筋について話します。\n最後に、TypeScript における class を利用したオブジェクト指向プログラミングについて、なぜそれが他の言語ほどには一般的に使われていないのか、について考察します。","descriptionJa":"これは、 yasaichi さんによる素晴らしいトーク [Active Recordから考える次の10年を見据えた技術選定](https://speakerdeck.com/yasaichi/architecture-decision-for-the-next-10-years-at-pixta) へのアンサートークです。\n私たちのチームでは新規サービスの開発を行っており、開発初期段階でいくつか技術的な判断を行いました。まず、API (public / internal) のプロトコルを GraphQL に統一しました。そして、内部の主要なサービスのうち一つに Ruby on Rails (ActiveRecord), もう一つに Node.js + Prisma という技術選定を行いました。\n社内で広く使われていた Rails という選択肢を取ったことは自然でしたが、もう一つのサービスに Node.js を選択したこと、また、ORM ライブラリとして ActiveRecord に思想が近い TypeORM ではなく、Prisma を選択したという決断の理由について、主にアーキテクチャ的背景から理由を説明します。\nまた、開発期間が2年弱経ち、見えてきた課題も取り上げます。特に、yasaichi さんの資料でも取り上げられている「トランザクションスクリプトを多く用いることになる」という課題について(実際に起きています)、それがどの程度深刻なのかの分析や、今後対処していく道筋について話します。\n最後に、TypeScript における class を利用したオブジェクト指向プログラミングについて、なぜそれが他の言語ほどには一般的に使われていないのか、について考察します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["qsona"],"startsAt":"15:40","endsAt":"16:10","room":"B","date":"day1"}},{"node":{"uuid":"javascript-maintaining-ecosystem-oss-struggles-and-challenges","title":"JavaScript エコシステムを維持する OSS の努力と課題","titleJa":"JavaScript エコシステムを維持する OSS の努力と課題","description":"(Untranslated) 現在、JavaScriptでの開発を行うには、実行環境であるブラウザやNode.jsだけでなく、様々なツールを使う必要があります。\nたとえば、TypeScript や Babel などのトランスパイラ、ESLintのようなリンターやそのプラグイン群、webpack や Rollup などのモジュールバンドラー、Prettier のようなコードフォーマッターなどがあります。\nそれらのツールの多くはコミュニティによる OSS として開発・維持が行われています。\n現代の Web の進化は速く、JavaScript も例外ではありません。ECMAScript 2015 以降、JavaScript はより良い言語になるよう成長を続けています。JavaScript の成長に伴って、周辺ツールも成長する必要があります。\nそして、その成長は各々のコミュニティの努力によって支えられています。\n我々が当たり前のように使っているツールの裏側で、その当たり前を実現するために行われている努力、そして抱えている課題についてお話します。","descriptionJa":"現在、JavaScriptでの開発を行うには、実行環境であるブラウザやNode.jsだけでなく、様々なツールを使う必要があります。\nたとえば、TypeScript や Babel などのトランスパイラ、ESLintのようなリンターやそのプラグイン群、webpack や Rollup などのモジュールバンドラー、Prettier のようなコードフォーマッターなどがあります。\nそれらのツールの多くはコミュニティによる OSS として開発・維持が行われています。\n現代の Web の進化は速く、JavaScript も例外ではありません。ECMAScript 2015 以降、JavaScript はより良い言語になるよう成長を続けています。JavaScript の成長に伴って、周辺ツールも成長する必要があります。\nそして、その成長は各々のコミュニティの努力によって支えられています。\n我々が当たり前のように使っているツールの裏側で、その当たり前を実現するために行われている努力、そして抱えている課題についてお話します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["sosuke-suzuki"],"startsAt":"12:10","endsAt":"12:40","room":"A","date":"day1"}},{"node":{"uuid":"case-study-of-production-development-of-a-client-side-ml-application-in-a-mobile-browser","title":"モバイルブラウザにおけるClient-side MLアプリケーションのプロダクション開発事例","titleJa":"モバイルブラウザにおけるClient-side MLアプリケーションのプロダクション開発事例","description":"(Untranslated) 私たちはフリマアプリ「メルカリ」を開発しています。私たちEdge AI Platformチームでは、スマートフォンのカメラで商品を写すだけで、瞬時にメルカリで取引されている類似商品のカテゴリや価格情報が得られるWebアプリケーションを開発し、ユーザーテストを行っています。\nこのアプリケーションは、カメラをかざすだけで情報を表示するために、物体検出や物体追跡といった機械学習モデルの推論や画像処理を行っています。\nさらに、レスポンスを速くしてスムーズでわかりやすいUXを提供するために、私たちはそれらの処理をサーバーサイドではなくブラウザ上で実行しています。このとき、WebAssemblyやWebGLといった技術を用いて、モバイルブラウザでも高速に動作するように実装しています。\n一般に、機械学習モデルや画像処理はコストの高い処理です。さらに、同じ処理をネイティブアプリケーションで実現することと比べて、モバイルブラウザではパフォーマンスが低下したり、技術的な制約で同じアルゴリズムの実現が難しかったりしました。 そのため、プロダクトとしてリリースするために、私たちは適切な技術選択を行ったり、ローエンドデバイスでも満足に動くようなチューニングをしたりする必要がありました。\n本発表では、以上のようなプロダクション開発中の試行錯誤で得られた、次のようなトピックを紹介する予定です。\nclient-side MLの技術動向、ライブラリの比較 ソフトウェアアーキテクチャや利用している技術スタック モバイルブラウザ向けのパフォーマンスチューニングの方法 ユーザーからのフィードバックとそれに関する改善の事例","descriptionJa":"私たちはフリマアプリ「メルカリ」を開発しています。私たちEdge AI Platformチームでは、スマートフォンのカメラで商品を写すだけで、瞬時にメルカリで取引されている類似商品のカテゴリや価格情報が得られるWebアプリケーションを開発し、ユーザーテストを行っています。\nこのアプリケーションは、カメラをかざすだけで情報を表示するために、物体検出や物体追跡といった機械学習モデルの推論や画像処理を行っています。\nさらに、レスポンスを速くしてスムーズでわかりやすいUXを提供するために、私たちはそれらの処理をサーバーサイドではなくブラウザ上で実行しています。このとき、WebAssemblyやWebGLといった技術を用いて、モバイルブラウザでも高速に動作するように実装しています。\n一般に、機械学習モデルや画像処理はコストの高い処理です。さらに、同じ処理をネイティブアプリケーションで実現することと比べて、モバイルブラウザではパフォーマンスが低下したり、技術的な制約で同じアルゴリズムの実現が難しかったりしました。 そのため、プロダクトとしてリリースするために、私たちは適切な技術選択を行ったり、ローエンドデバイスでも満足に動くようなチューニングをしたりする必要がありました。\n本発表では、以上のようなプロダクション開発中の試行錯誤で得られた、次のようなトピックを紹介する予定です。\nclient-side MLの技術動向、ライブラリの比較 ソフトウェアアーキテクチャや利用している技術スタック モバイルブラウザ向けのパフォーマンスチューニングの方法 ユーザーからのフィードバックとそれに関する改善の事例","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["tomohiro-kato"],"startsAt":"16:20","endsAt":"16:50","room":"B","date":"day1"}},{"node":{"uuid":"universal-devtools-for-all-environments","title":"Universal DevTools for all environments","titleJa":"Universal DevTools for all environments","description":"(Untranslated) モバイル端末の普及に伴い、WebView上のWebアプリ、PWA、LIFF、Miniアプリなど、Webブラウザにから独立したWebアプリケーションの需要が高まっています。しかし、これらモバイル端末向けWebアプリケーションにはブラウザ固有のDevToolが存在せず、デバッグが難しく開発体験が損なわれるという課題があります。\n本セッションでは、Chrome DevTools Protocolを利用した、任意の環境で動作するWebアプリケーションをChrome DevToolsでデバッグ可能にする新しいDevToolsを紹介します。","descriptionJa":"モバイル端末の普及に伴い、WebView上のWebアプリ、PWA、LIFF、Miniアプリなど、Webブラウザにから独立したWebアプリケーションの需要が高まっています。しかし、これらモバイル端末向けWebアプリケーションにはブラウザ固有のDevToolが存在せず、デバッグが難しく開発体験が損なわれるという課題があります。\n本セッションでは、Chrome DevTools Protocolを利用した、任意の環境で動作するWebアプリケーションをChrome DevToolsでデバッグ可能にする新しいDevToolsを紹介します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["kohei-ueno"],"startsAt":"13:20","endsAt":"13:50","room":"B","date":"day1"}},{"node":{"uuid":"machine-learning-with-js","title":"Machine Learning with JS","titleJa":"Machine Learning with JS","description":"This talk is dedicated to showing how the Machine Learning can be used with on web with JavaScript using Tensorflow.js and React.js","descriptionJa":"（未翻訳）This talk is dedicated to showing how the Machine Learning can be used with on web with JavaScript using Tensorflow.js and React.js","spokenLanguage":"en","slideLanguage":"en","speakerIDs":["asiya"],"startsAt":"17:00","endsAt":"17:10","room":"A","date":"day1"}},{"node":{"uuid":"a-tour-of-design-patterns-for-functional-programming-with-ramdajs","title":"関数型プログラミングのデザインパターンひとめぐり with Ramda.js","titleJa":"関数型プログラミングのデザインパターンひとめぐり with Ramda.js","description":"(Untranslated) クライアントサイドにおいては、React や Elm の台頭により \"関数型プログラミング\" の手法が注目を浴びるようになったかと思います。この LT では、頻出するデザインパターンを Ramda.js というライブラリを用いて解説します。\n高階関数や型を単独で紹介するのではなく、それらを複合的に利用したユースケースをご紹介します。","descriptionJa":"クライアントサイドにおいては、React や Elm の台頭により \"関数型プログラミング\" の手法が注目を浴びるようになったかと思います。この LT では、頻出するデザインパターンを Ramda.js というライブラリを用いて解説します。\n高階関数や型を単独で紹介するのではなく、それらを複合的に利用したユースケースをご紹介します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["kazuyuki-takase-"],"startsAt":"17:10","endsAt":"17:20","room":"A","date":"day1"}},{"node":{"uuid":"web-front-end-architecture-and-transition-with-an-eye-on-organizational-phases","title":"組織フェーズを見据えたWebフロントエンドのアーキテクチャと変遷","titleJa":"組織フェーズを見据えたWebフロントエンドのアーキテクチャと変遷","description":"(Untranslated) 10年間で約15万行のコードを抱え、jQuery -> React + DDD ->  React + Redux とアーキテクチャの変遷を辿ってきたChatworkを事例として、\n組織フェーズの変化によって発生する課題と、それらをアーキテクチャの観点からどのように乗り越えるか紐解きたいと思います。","descriptionJa":"10年間で約15万行のコードを抱え、jQuery -> React + DDD ->  React + Redux とアーキテクチャの変遷を辿ってきたChatworkを事例として、\n組織フェーズの変化によって発生する課題と、それらをアーキテクチャの観点からどのように乗り越えるか紐解きたいと思います。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["tetsuya-shibutani"],"startsAt":"17:20","endsAt":"17:30","room":"A","date":"day1"}},{"node":{"uuid":"bundle-size-optimization-in-future-javascript","title":"Bundle Size Optimization in Future JavaScript","titleJa":"Bundle Size Optimization in Future JavaScript","description":"(Untranslated) Core Web Vitals の登場などにより、フロントエンド開発におけるパフォーマンスチューニングの重要性が増しています。\nその中でも、バンドルサイズの削減については Tree-Shaking や Dead Code Elimination が普及していますが、未だ一般的な Class-based OOP 等のプログラミングパターンとは相性が悪く、アプリケーション開発者が設計レベルから意識する必要があります。\nこの LT では、現在の JavaScript でバンドルサイズが膨らんでしまうパターンを紹介し、それらが将来的に解決される可能性を、TC39 で議論中の仕様やエコシステムの進化などから考察します。","descriptionJa":"Core Web Vitals の登場などにより、フロントエンド開発におけるパフォーマンスチューニングの重要性が増しています。\nその中でも、バンドルサイズの削減については Tree-Shaking や Dead Code Elimination が普及していますが、未だ一般的な Class-based OOP 等のプログラミングパターンとは相性が悪く、アプリケーション開発者が設計レベルから意識する必要があります。\nこの LT では、現在の JavaScript でバンドルサイズが膨らんでしまうパターンを紹介し、それらが将来的に解決される可能性を、TC39 で議論中の仕様やエコシステムの進化などから考察します。","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["yuku-kotani"],"startsAt":"17:30","endsAt":"17:40","room":"A","date":"day1"}},{"node":{"uuid":"accelerating-edge-computing","title":"加速するEdge Computing ","titleJa":"加速するEdge Computing ","description":"(Untranslated) Cloudflare Worker, Vercel Edge Function, Compute@Edge, Deno deploy, AWS Lambda@Edgeなど, Edge でコードを実行するランタイムはどんどん増えています.\nEdgeランタイムでコードを実行することは, URL Rewritesによるorigin serverの振り分け, HTTP Headerの加工, Edgeでの認証などに有用で, それらの処理をHTTP Request元のclientに地理的に近い環境で実行可能になりパフォーマンスの向上が見込めます.\nこれらのユースケースの整理をし, さらに Compute@Edge で触れられているEdge Nativeなアプリケーションの構築といったEdgeの可能性についても触れて, Edgeで何をできるのか, 何をすべきでないのかしゃべります.","descriptionJa":"Cloudflare Worker, Vercel Edge Function, Compute@Edge, Deno deploy, AWS Lambda@Edgeなど, Edge でコードを実行するランタイムはどんどん増えています.\nEdgeランタイムでコードを実行することは, URL Rewritesによるorigin serverの振り分け, HTTP Headerの加工, Edgeでの認証などに有用で, それらの処理をHTTP Request元のclientに地理的に近い環境で実行可能になりパフォーマンスの向上が見込めます.\nこれらのユースケースの整理をし, さらに Compute@Edge で触れられているEdge Nativeなアプリケーションの構築といったEdgeの可能性についても触れて, Edgeで何をできるのか, 何をすべきでないのかしゃべります.","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["shinyaigeek"],"startsAt":"17:40","endsAt":"17:50","room":"A","date":"day1"}},{"node":{"uuid":"building-markdown-editor-using-rusts-parser","title":"Building markdown editor using Rust's parser","titleJa":"Building markdown editor using Rust's parser","description":"(Untranslated) このトークでは、wasmとRustのパーサーを使用したマークダウンエディタを作った時の話をします。\nwasm採用のモチベーションやユースケース、Rustのコードをwasm pkg化する方法、wasm pkgをReact Hookでロードする方法について紹介します。\nこのトークが終わる頃には、wasmのユースケースの一部を把握し、具体的な実装方法が身に付いていることを願っています。\nhttps://blog.yagipy.me/md-editor-with-rust-parser-on-the-web","descriptionJa":"このトークでは、wasmとRustのパーサーを使用したマークダウンエディタを作った時の話をします。\nwasm採用のモチベーションやユースケース、Rustのコードをwasm pkg化する方法、wasm pkgをReact Hookでロードする方法について紹介します。\nこのトークが終わる頃には、wasmのユースケースの一部を把握し、具体的な実装方法が身に付いていることを願っています。\nhttps://blog.yagipy.me/md-editor-with-rust-parser-on-the-web","spokenLanguage":"ja","slideLanguage":"ja","speakerIDs":["hiroyuki-yagihashi"],"startsAt":"17:50","endsAt":"18:00","room":"A","date":"day1"}},{"node":{"uuid":"asynchronicity-the-right-way-understanding-the-basics-of-asynchronous-javascript-when-to-and-when-not-to-use-it","title":"Asynchronicity, the right way: Understanding the basics of asynchronous JavaScript, when to and when not to use it.","titleJa":"Asynchronicity, the right way: Understanding the basics of asynchronous JavaScript, when to and when not to use it.","description":"Asynchronicity, the right way: Understanding the basics of asynchronous JavaScript, when to and when not to use it. \n1. Introduction to the concept of asynchronous vs synchronous.\n2. Introduction to myself, and how I use JS in my everyday work.\n3. Why the need for asynchronous behaviour\n4. When to not use asynchronous JS\n5. Understanding Promises, and how to use them correctly.\n6. Use cases\n7. Conclusion","descriptionJa":"（未翻訳）Asynchronicity, the right way: Understanding the basics of asynchronous JavaScript, when to and when not to use it. \n1. Introduction to the concept of asynchronous vs synchronous.\n2. Introduction to myself, and how I use JS in my everyday work.\n3. Why the need for asynchronous behaviour\n4. When to not use asynchronous JS\n5. Understanding Promises, and how to use them correctly.\n6. Use cases\n7. Conclusion","spokenLanguage":"en","slideLanguage":"en","speakerIDs":["julien-hora"],"startsAt":"12:50","endsAt":"13:20","room":"A","date":"day1"}},{"node":{"uuid":"state-of-css-2021-survey-results","title":"State of CSS 2021 Survey Results","titleJa":"State of CSS 2021 Survey Results","description":"A brief overview of the results for the 2021 State of CSS survey","descriptionJa":"（未翻訳）A brief overview of the results for the 2021 State of CSS survey","spokenLanguage":"en","slideLanguage":"en","speakerIDs":["sacha-greif"],"startsAt":"18:00","endsAt":"18:10","room":"A","date":"day1"}},{"node":{"uuid":"opening","title":"Opening by Yosuke Furukawa","titleJa":"オープニング by Yosuke Furukawa","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"12:00","endsAt":"12:10","room":"A","date":"day1"}},{"node":{"uuid":"day1-break-1240-1250","title":"Break","titleJa":"休憩","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"12:40","endsAt":"12:50","room":"A","date":"day1"}},{"node":{"uuid":"day1-break-1350-1400","title":"Break","titleJa":"休憩","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"13:50","endsAt":"14:00","room":"A","date":"day1"}},{"node":{"uuid":"day1-break-1500-1510","title":"Break","titleJa":"休憩","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"15:00","endsAt":"15:10","room":"A","date":"day1"}},{"node":{"uuid":"day1-break-1610-1520","title":"Break","titleJa":"休憩","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"16:10","endsAt":"16:20","room":"A","date":"day1"}},{"node":{"uuid":"day1-break-1650-1700","title":"Break","titleJa":"休憩","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"16:50","endsAt":"17:00","room":"A","date":"day1"}},{"node":{"uuid":"day1-break-1840-1850","title":"Break","titleJa":"休憩","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"18:40","endsAt":"18:50","room":"A","date":"day1"}},{"node":{"uuid":"ending","title":"Ending","titleJa":"エンディング","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"19:20","endsAt":"19:30","room":"A","date":"day1"}},{"node":{"uuid":"drink-party","title":"Drink Party","titleJa":"懇親会","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"19:30","endsAt":"21:00","room":"A","date":"day1"}},{"node":{"uuid":"sponsor-talk-wantedly","title":"Sponsor talk","titleJa":"スポンサートーク","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"12:50","endsAt":"13:20","room":"C","date":"day1"}},{"node":{"uuid":"sponsor-talk-kaonavi","title":"Sponsor talk","titleJa":"スポンサートーク","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"13:20","endsAt":"13:50","room":"C","date":"day1"}},{"node":{"uuid":"sponsor-talk-ubie","title":"Sponsor talk","titleJa":"スポンサートーク","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"14:00","endsAt":"14:30","room":"C","date":"day1"}},{"node":{"uuid":"sponsor-talk-recruit","title":"Sponsor talk","titleJa":"スポンサートーク","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"14:30","endsAt":"15:00","room":"C","date":"day1"}},{"node":{"uuid":"sponsor-talk-hey","title":"Sponsor talk","titleJa":"スポンサートーク","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"15:10","endsAt":"15:40","room":"C","date":"day1"}},{"node":{"uuid":"sponsor-talk-nota","title":"Sponsor talk","titleJa":"スポンサートーク","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"15:40","endsAt":"16:10","room":"C","date":"day1"}},{"node":{"uuid":"sponsor-talk-twilio","title":"Sponsor talk","titleJa":"スポンサートーク","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"16:20","endsAt":"16:50","room":"C","date":"day1"}},{"node":{"uuid":"sponsors-lt","title":"Sponsors LT","titleJa":"スポンサーLT","description":null,"descriptionJa":null,"spokenLanguage":null,"slideLanguage":null,"speakerIDs":[],"startsAt":"18:10","endsAt":"18:40","room":"A","date":"day1"}},{"node":{"uuid":"how-projects-are-born-and-run-in-a-web-browser-engine","title":"How projects are born and run in a web browser engine","titleJa":"How projects are born and run in a web browser engine","description":"In this talk I will talk about a few examples and thoughts about how a project might be born and worked in a large-scale browser engine like Chromium. It's partially about scoping, designing, planning and executing, but also largely about collaboration, communication, and a lot of struggles.","descriptionJa":"（未翻訳）In this talk I will talk about a few examples and thoughts about how a project might be born and worked in a large-scale browser engine like Chromium. It's partially about scoping, designing, planning and executing, but also largely about collaboration, communication, and a lot of struggles.","spokenLanguage":"en","slideLanguage":"en","speakerIDs":["kinuko-yasuda"],"startsAt":"18:50","endsAt":"19:20","room":"A","date":"day1"}}]}}}