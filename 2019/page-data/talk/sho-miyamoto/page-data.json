{"componentChunkName":"component---src-templates-speaker-tsx","path":"/talk/sho-miyamoto","webpackCompilationHash":"7c474cb80f00bd88ba12","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"speakers":[{"uuid":"sho-miyamoto","name":"Sho Miyamoto","biography":"Working on {browser, server, edge}-side web development at newspaper company. Interested in performance, browser and standards.\n\nhttps://github.com/antidotech\nhttps://twittercom/antidotech","biographyJa":"TODo"}],"avatars":[{"originalName":"sho-miyamoto.jpg","originalImg":"/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/ec650/sho-miyamoto.jpg","aspectRatio":1,"src":"/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/2be9e/sho-miyamoto.jpg","srcSet":"/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/79993/sho-miyamoto.jpg 66w,\n/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/2e0c2/sho-miyamoto.jpg 131w,\n/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/2be9e/sho-miyamoto.jpg 262w,\n/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/7d55c/sho-miyamoto.jpg 393w,\n/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/ec650/sho-miyamoto.jpg 460w","srcWebp":"/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/fabb6/sho-miyamoto.webp","srcSetWebp":"/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/7fc16/sho-miyamoto.webp 66w,\n/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/78dfd/sho-miyamoto.webp 131w,\n/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/fabb6/sho-miyamoto.webp 262w,\n/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/b3aeb/sho-miyamoto.webp 393w,\n/2019/static/1d21de2f33eb5593d11d6fb65e5373a5/2ea4d/sho-miyamoto.webp 460w","sizes":"(max-width: 262px) 100vw, 262px"}],"talk":{"uuid":"sho-miyamoto","title":"Wrap-up: Runtime-friendly JavaScript","titleJa":"Wrap-up: Runtime-friendly JavaScript","description":"Let's wrap up what runtime-friendly performant JavaScript is like, introducing how runtime(such as v8, node.js etc.) handles scripts: Internal Representation, JIT, Eventloop etc. I will also mention tools(node options, chrome devtool) and the overhead of normal language feature(like object instantiation and Map/Set).\n\nPlot (draft)\n- Fundamentals\n   - Runtime\n   - IR & JIT\n- Node\n   - Async & non-blocking I/O\n   - Stream\n   - Eventloop\n       - libuv\n- V8\n   - Crankshaft, FullCodeGen, TurboFun, Ignition\n- Internal Representation\n   - Object IR\n       - elements & properties\n       - Hidden Class\n       - JSON.parse\n   - String IR\n       - flatstr\n   - Array IR\n   - Number IR\n- JIT\n   - Hot code\n   - Inline Cache\n- Tools\n   - trace: opt, deopt, ic\n   - chrome devtool\n   - (d8)\n- Principle of high performance\n   - Application\n       - Maintainability is first\n           - Various people will join your team\n       - Choose performant libraries\n           - Core functionarities are run many times\n       - Use util library instead of your own ones\n           - tested\n           - performant\n           - used\n   - Library\n       - Low-overhead is nicer\n           - (TBD)\n- Techniques\n   - Avoid runtime overhead\n       - Object instantiation\n       - Map, Set, Object\n       - Regexp\n   - Avoid blocking I/O\n       - Sync, Async\n       - Macro/micro tasks\n   - PIFE/IIFE\n- Performant libraries\n   - bluebird\n   - ajv\n   - pico(nearForm)\n   - fastify(nearForm)\n- Appendix\n   - node-gyp\n   - quickjs, hermes","descriptionJa":"実行時に高速ランタイムフレンドリーな JavaScript とはどのようなものなのか？\nこのトークでは、v8, node.js などのランタイムが Internal Representation, JIT, Eventloop などを使用し、スクリプトをどの用に処理しているかについて話します。\nさらに、node options や chrome devtool などのツールを使う上でのテクニックや、\nobject のインスタンス化や Map, Set などの言語機能がどのような Overhead を抱えているかについて発表します。\n\nPlot (draft)\n\n- Fundamentals\n  - Runtime\n  - IR & JIT\n- Node\n  - Async & non-blocking I/O\n  - Stream\n  - Eventloop\n    - libuv\n- V8\n  - Crankshaft, FullCodeGen, TurboFun, Ignition\n- Internal Representation\n  - Object IR\n    - elements & properties\n    - Hidden Class\n    - JSON.parse\n  - String IR\n    - flatstr\n  - Array IR\n  - Number IR\n- JIT\n  - Hot code\n  - Inline Cache\n- Tools\n  - trace: opt, deopt, ic\n  - chrome devtool\n  - (d8)\n- Principle of high performance\n  - Application\n    - Maintainability is first\n      - Various people will join your team\n    - Choose performant libraries\n      - Core functionarities are run many times\n    - Use util library instead of your own ones\n      - tested\n      - performant\n      - used\n  - Library\n    - Low-overhead is nicer\n      - (TBD)\n- Techniques\n  - Avoid runtime overhead\n    - Object instantiation\n    - Map, Set, Object\n    - Regexp\n  - Avoid blocking I/O\n    - Sync, Async\n    - Macro/micro tasks\n  - PIFE/IIFE\n- Performant libraries\n  - bluebird\n  - ajv\n  - pico(nearForm)\n  - fastify(nearForm)\n- Appendix\n  - node-gyp\n  - quickjs, hermes","spokenLanguage":"ja","slideLanguage":"","speakerIDs":["sho-miyamoto"],"date":"day1","startsAt":"15:30","endsAt":"16:00","room":"B"}}}}